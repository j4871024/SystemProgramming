# 第 5 組 系統程式-期末報告

## 分工

### 1112914 宋冠穎 (25 %)

* Regular Expression -> Dotted Item -> NFA
* NFA -> DFA
* 使用 LaTex 將 Dotted Item 手寫過程整理成數位檔案
* Demo
* 簡報製作

### 1112919 丁柏凱 (25 %)

* NFA -> DFA
* 使用 LaTex 將 NFA -> DFA 手寫過程整理成數位檔案
* Python Program
* Demo
* inkscape 繪圖
* 簡報製作

### 1112929 詹佳瑜 (10 %)

* 想測資
* 檢查輸入 & 輸出

### 1112946 王嘉汶 (18 %)

* inkscape 繪圖
* Demo
* 簡報製作

### 1112957 顏琦恩 (22 %)

* Regular Expression -> Dotted Item -> NFA
* NFA -> DFA
* 簡報製作
* 影片剪輯

## 題目 & 流程圖
![未命名 (2)](https://hackmd.io/_uploads/HydVwYTQeg.png)


1. 利用 dotted item method 把以下的 regular expressions 轉 NFA/DFA
![image](https://hackmd.io/_uploads/rkrW4Vpmgx.png)
2. 寫一個 lexical analyzer 來分析讀到的是哪個 token (Separators and Brackets, Binary Operators, Keywords, Comments, Identity, Integer and Float)
![image](https://hackmd.io/_uploads/S17yv4T7lx.png)
==注意: 不能用 lex 或 similar lexical analyzer==
 
---

## Regular Expression -> NFA

將 Regular Expression 利用 dotted item method 轉換成 NFA

NFA:
- 可以對同一個輸入字元有多個轉移方向
- 可以存在 ε-transition（空轉移，不需輸入符號即可移動)

dotted item method
* 定義
    * dotted item 是一個帶有「dot `·`」的產生式（production），標記目前已經分析到哪個位置。
點號位於產生式右側的某個位置，表示目前已經「看到」這個位置前的所有符號，下一步將會分析點號後的符號。
* 範例
    * 一個正規表達式
    `A → XYZ`
    * 會有以下 dotted items
        1. `A → · XYZ`：表示尚未處理任何符號
        2. `A → X · YZ`：表示已處理了 X，下一步要處理 Y
        3. `A → XY · Z`：表示已處理了 X 和 Y
        4. `A → XYZ ·`：表示整個產生式已處理完

* Character moves
    * 基本項目（Basic item）
        * 如果項目中的點（dot）位於基本項目前方，則在輸入字元與基本項目相符時，該項目會將點移動到下一個字元位置。
    * 非基本項目（Non-basic item） 
        * 項目中的點無法直接跨過一個字元，因為它沒有定義一組可比對的字元集合（無法判斷輸入字元是否符合）。
        * 如 $^*$ 、 $^+$ 、 $^?$ 、 $|$

==dotted item 過程為簡化狀態機有進行部分簡化==
* 一般 dotted item 中 Non-basic item $\varepsilon -move$ 規則
![temp(1)](https://hackmd.io/_uploads/HygJMraQxg.jpg)
* 簡化範例: (2) 讀完 letter 後，移到 (4) 表示括號內容讀取完畢，與==移到 (1) 表示再次讀取括號內容==。
![image](https://hackmd.io/_uploads/ByNmXHpmlx.png)

### 1. underscore
underscore有可能為
⓪:接下來要匹配' _ '
①:已經完成匹配' _ '
![image](https://hackmd.io/_uploads/r1yYA4Tmle.png)
![underscore](https://hackmd.io/_uploads/SyvA_STXxx.png)

### 2. letter
letter有可能為
⓪接下來要匹配[A-Za-z]
①已經完成匹配[A-Za-z]
![image](https://hackmd.io/_uploads/SJsFR4T7ex.png)
![letter](https://hackmd.io/_uploads/ry8lKr6Xlx.png)

### 3. digit
![image](https://hackmd.io/_uploads/B1k5AEpQle.png)
![digit](https://hackmd.io/_uploads/ByReFBpmxe.png)

### 4. underscore_tail
![image](https://hackmd.io/_uploads/B1XcCNTXle.png)
![underscore_tail](https://hackmd.io/_uploads/H17ZKraXgx.png)

### 5. id
![image](https://hackmd.io/_uploads/H1F5REaQel.png)
![id](https://hackmd.io/_uploads/r1ObtS67le.png)

### 6. fraction
![image](https://hackmd.io/_uploads/Sk0504TQle.png)
![fraction](https://hackmd.io/_uploads/B1JfFS6Xel.png)

### 7. optional_exponent
![image](https://hackmd.io/_uploads/SyzjR4TXge.png)
![optional_exponent](https://hackmd.io/_uploads/HJEMKSa7el.png)

### 8. integer
![image](https://hackmd.io/_uploads/ryDoC4a7el.png)
![integer](https://hackmd.io/_uploads/Bk4HUwpXlx.png)


### 9. float
![image](https://hackmd.io/_uploads/S1ni0467xg.png)
![float](https://hackmd.io/_uploads/rJJXFBT7xx.png)

---

## NFA -> DFA

DFA
- 在任一狀態下，對於一個輸入字元，最多只能有一條對應的邊
- 不能對同一個輸入字元有兩種選擇

ε-closure
* ε-closure(S)： 從S這個狀態出發，能沿著ε邊一直走下去的所有狀態就是ε-closure(S)

* ε-closure(T)： T可以定義多個狀態來出發，就是可以不只closure一個狀態
* move(S, 字元)： 從T中的所有狀態出發，根據輸入字元，所能轉移到的所有狀態

步驟
* 首先Initializations： 一開始只放一個初始狀態，move後並設為 A
![image](https://hackmd.io/_uploads/rkP83S6mle.png)

* 從初始狀態開始move(S, 字元)，表示從S中的所有狀態出發，根據輸入字元，所能轉移到的所有狀態
* 再ε-closure(S)，也就是將ε消掉，如果有新集合，設定為新狀態(B、C、D...)，重複下去直到沒有新狀態。
![image](https://hackmd.io/_uploads/Hk2dqHaQxe.png)
* 再將每個 states 化成 transition diagram
![image](https://hackmd.io/_uploads/HJLYcHTmlg.png)

我們針對剛剛產生的 9 個 NFA 圖形，來產生 DFA：
### 1. underscore
![underscore](https://hackmd.io/_uploads/SysQXIaXlg.png)

首先他的初始狀態是0，對她closure後因為沒有ε，所以一樣是1的集合，然後把它設為A狀態
再來要對所有可能輸入的字元做move，那這邊所有可能讀到的只有底線，所以move(A,_ )開始找可能轉移到的所有狀態，那他會到的只有1，
接下來對1，ε-closure，那他一樣因為沒有ε的邊，所以一樣只有1，且為新狀態所以設成B
再從狀態B重複以上步驟直到沒有新狀態，畫出轉移表
![image](https://hackmd.io/_uploads/S17GVV6mxg.png)

![image](https://hackmd.io/_uploads/BJ2MNNpmlx.png)

### 2. letter
![letter](https://hackmd.io/_uploads/ByWBX8aQlx.png)

以此類推underscore
![image](https://hackmd.io/_uploads/BkKpWH67gg.png)

![image](https://hackmd.io/_uploads/ByJ0WHpXxg.png)

### 3. digit
![digit](https://hackmd.io/_uploads/HJ_HQUamel.png)

![image](https://hackmd.io/_uploads/rkMObBpmxl.png)

![image](https://hackmd.io/_uploads/r1O_WHTQle.png)

### 4. underscore_tail
![underscore_tail](https://hackmd.io/_uploads/rkmIXUpQle.png)

![image](https://hackmd.io/_uploads/ryHKZSpQeg.png)

![image](https://hackmd.io/_uploads/BJM5-BTmxg.png)

![image](https://hackmd.io/_uploads/BkqcZBpmee.png)

![image](https://hackmd.io/_uploads/ByMibH6Xxg.png)

### 5. id
![id](https://hackmd.io/_uploads/BJqIXLpmgg.png)

![image](https://hackmd.io/_uploads/rJ-LpETXgx.png)

![image](https://hackmd.io/_uploads/BJZP6E67ge.png)

![image](https://hackmd.io/_uploads/ryjD64pQel.png)

![image](https://hackmd.io/_uploads/SJ4OaETXgl.png)

### 6. fraction
![fraction](https://hackmd.io/_uploads/SkbDXUpmex.png)

![image](https://hackmd.io/_uploads/r10fyS6Xge.png)

![image](https://hackmd.io/_uploads/H1K71Hpmgx.png)

![image](https://hackmd.io/_uploads/S11EkHamee.png)

![image](https://hackmd.io/_uploads/S1v4yH6mxg.png)

### 7. optional_exponent
![optional_exponent](https://hackmd.io/_uploads/S1ZYX86Qee.png)

![image](https://hackmd.io/_uploads/SyDrJS6Xex.png)

![image](https://hackmd.io/_uploads/r1eIJH6mgl.png)

![image](https://hackmd.io/_uploads/HJtUyBaQxx.png)

![image](https://hackmd.io/_uploads/H1ewJrT7xx.png)

![image](https://hackmd.io/_uploads/rkKwyHTXee.png)

### 8. integer
![integer](https://hackmd.io/_uploads/Byx8IPpXxe.png)

![image](https://hackmd.io/_uploads/rysR-HpQxe.png)

![image](https://hackmd.io/_uploads/B1eJGBpQgx.png)

### 9. float
![float](https://hackmd.io/_uploads/Syy5m8aXex.png)

![image](https://hackmd.io/_uploads/ry_XZBp7xx.png)

![image](https://hackmd.io/_uploads/rJzVbSTXgl.png)

![image](https://hackmd.io/_uploads/S1c4-raXee.png)

![image](https://hackmd.io/_uploads/HkWSbrpXel.png)

---

## DFA + DFA -> NFA -> DFA

接下來我們要處理一些複合型的 token

### 1. id

第一個是 id

* id 
![image](https://hackmd.io/_uploads/SJ4OaETXgl.png)

可以看到，在 id 的 DFA transition table 裡面有一個叫做 underscore_tail 的東西，它還可以再拆解，我們前面的 DFA 也有提到

* underscore_tail
![image](https://hackmd.io/_uploads/ByMibH6Xxg.png)

於是我們可以通過 id 和 underscore_tail 的 DFA Transition table，來重構出一張新的 NFA 圖形:
![id_plus](https://hackmd.io/_uploads/H1KdFramee.png)


接著將這個 NFA 再轉換成 DFA，就像我們前面有做過的方式，這邊就不再重複。

![image](https://hackmd.io/_uploads/BJqRQHpmxg.png)

![image](https://hackmd.io/_uploads/rkByNH6Xle.png)

![image](https://hackmd.io/_uploads/rypy4BaXxl.png)

![image](https://hackmd.io/_uploads/SkHgNSTXge.png)

完成後，就可以得到新的 id 的 DFA Transition table:

![image](https://hackmd.io/_uploads/SyjZNSaXee.png)

### 2. float

接下來是 float 的部分，在 float 的 DFA transition table 中，可以看到也有一個 optional_exponent，也是可以再拆解

* float
![image](https://hackmd.io/_uploads/ByywzwT7gx.png)

* optional_exponent
![image](https://hackmd.io/_uploads/H1edMPpQel.png)

我們就一樣結合 float 和 optional_exponent 的 DFA transition table，產生新的 float NFA

![float_plus](https://hackmd.io/_uploads/S1FpYSpQxg.png)

再由這個新的 NFA 來產生 DFA

![image](https://hackmd.io/_uploads/H1V8Vr6Xgx.png)

![image](https://hackmd.io/_uploads/B1C84rpQgg.png)

![image](https://hackmd.io/_uploads/SyLw4Bamex.png)

![image](https://hackmd.io/_uploads/ryJuES6mex.png)

![image](https://hackmd.io/_uploads/HycOEBpQxg.png)

![image](https://hackmd.io/_uploads/ByrFVSaXee.png)

![image](https://hackmd.io/_uploads/B1aYEB67xe.png)

完成後就可以得到新的 DFA transition table

---

## 程式

我們的程式是用 ==python== 來實作

### 讀取字元

我們首先要逐個字元來讀取，並判斷讀取到什麼類型的字元:

![image](https://hackmd.io/_uploads/Hk4pkU67el.png)

除了英文字母跟數字之外，還要判斷底線和空格等等。

如果讀取到的是空格的類別 layout，就直接跳過:

![image](https://hackmd.io/_uploads/HkEdoFa7le.png)

處理完空格之後，題目要求我們要可以辨識出:
(Separators and Brackets, Binary Operators,
Keywords, Comments, Identity, Integer, Float)

所以我們先定義一下每一個類別的 token

因為 Separators and Brackets, Binary Operators, Keywords 這幾種，裡面都是 or 的關係，像是 Keywords 

![image](https://hackmd.io/_uploads/HJUfBHamgg.png)

就會是有列舉出來的這幾種之一，所以簡單的用 list 的方式來處理

![image](https://hackmd.io/_uploads/rJQIFIaQlx.png)

那 Comments 的部分，因為需要識別開頭和結尾，所以額外寫他的規則:

![image](https://hackmd.io/_uploads/SJLfwB6Xxx.png)

讀取了開頭的 \/\* 後，判斷接下來是不是讀到 \*，如果不是的話，就會一直停在狀態 2，這樣就可以判斷出，是不是完整的註解 \/\* \*\/ 配對，也就是看註解符號有沒有閉合

### id

接下來是 ID 的部分，這邊看到的是重構後的 transition table，我們需要把 DFA 的狀態轉移，放入到程式中

* DFA(重構後)
![image](https://hackmd.io/_uploads/SyjZNSaXee.png)

將原本的狀態 A~D 重新編號成 0~3 狀態，在 python 程式中，使用 dictionary 的方式，來進行對應

![image](https://hackmd.io/_uploads/Bkd7sv6Qee.png)

像這邊

從原本初始狀態 A，也就是 0，如果讀了 letter，就會跑到狀態 B，也就是狀態 1，那程式中就寫上，狀態 0，讀取 letter，就切換到狀態 1。

那在狀態 B，也就是 1，如果讀取了 letter 或是 digit，還是會留在狀態 B，讀取 underscore 會轉換到狀態 C，那程式中就寫上，狀態 1，讀取 letter，切換到狀態 1，讀取 digit，切換到狀態 1，讀取 underscore，切換到狀態 2。

後面依此類推，最後我們需要決定一下，在哪些狀態，是可以最為合法的結束狀態。

狀態 A 是初始狀態，當然不能當作是結束狀態。

而狀態 B，是從 A 讀了英文字母之後，或是 B 自己讀了字元或數字，也就是這串輸入的最後是英文字母或是數字，因此狀態 B 是可以作為結束狀態的。

狀態 C，是狀態 B 或 D 讀取了底線而來，也就是這串輸入的最後是底線，那根據規則:

![image](https://hackmd.io/_uploads/ryhs6Hpmel.png)

id 的結尾不可能是底線，所以狀態 C 不能當作結束狀態。

狀態 D，是由狀態 C 讀了英文字母或數字而來，也就是底線後面跟了英文字母或數字，或是從狀態 D 再讀英文字母或數字，因此這串輸入的最後面是英文字母或是數字，可以當作結束狀態。

id 這個 DFA，可以做為結束狀態的有 B 和 D，也就是狀態 1 和 3，因此我們把合法的結束狀態記錄下來:

![image](https://hackmd.io/_uploads/BJLuRH6Xel.png)

另外的 float 和 integer 也是一樣的做法，把 DFA 的結果寫入程式中。

* float
![image](https://hackmd.io/_uploads/SyPpKwaXxx.png)

* integer
![image](https://hackmd.io/_uploads/HywkcDTXlg.png)

那程式中一些迭代的過程，我們就不去提細節。

### 完整程式碼

```python {class=line-numbers}
# 在同個目錄下，建立 input.txt 檔案
# 裡面放入要測試的輸入

def char_type(ch):
    ascii_val = ord(ch)  # 取得 ASCII 編碼

    # 判斷是否為字母 (A-Z, a-z)
    if (65 <= ascii_val <= 90) or (97 <= ascii_val <= 122):
        return 'letter'

    # 判斷是否為數字 (0-9)
    elif 48 <= ascii_val <= 57:
        return 'digit'

    # 判斷是否為底線 (_)
    elif ascii_val == 95:
        return 'underscore'

    # 判斷是否為空白字元 (空格、tab、換行、Enter)
    elif ascii_val in (9, 10, 13, 32):
        return 'layout'

    else:
        return ch  # 其他字元


# 比較簡單的定義，只會是裡面的其中一個

# Separators
separators = {';'}

# Brackets
brackets = {'(', ')', '[', ']', '{', '}'}

# Binary Operators
binary_Operators = ['<=', '>=', '<>', '==', '+', '-', '*', '/', '<', '>', '=']

# Keywords
keywords = {'int', 'float', 'bool', 'void',
            'while', 'if', 'else', 'for', 'return'}

# Comments DFA
dfa_comments = {
    0: {'/': 1},
    1: {'*': 2},
    2: {'*': 3, 'other': 2},
    3: {'/': 4, '*': 3, 'other': 2}
}
comments_accept_states = {4}

# integer DFA
dfa_int = {
    0: {'digit': 1},
    1: {'digit': 1}
}
int_accept_states = {1}

# id DFA
dfa_id = {
    0: {'letter': 1},
    1: {'letter': 1, 'digit': 1, 'underscore': 2},
    2: {'letter': 3, 'digit': 3},
    3: {'letter': 3, 'digit': 3, 'underscore': 2},
}

id_accept_states = {1, 3}

# float DFA
dfa_float = {
    0: {'digit': 0, '.': 1},
    1: {'digit': 2},
    2: {'digit': 2, 'E': 3},
    3: {'digit': 5, '+': 4, '-': 4},
    4: {'digit': 5},
    5: {'digit': 5},
}
float_accept_states = {2, 5}


def run_dfa(dfa, accept_states, text, start):
    state = 0
    i = start
    last_accept = -1
    last_accept_pos = start - 1
    length = len(text)

    while i < length:
        c = text[i]
        t = char_type(c)

        # Comments DFA 特殊狀態轉移
        if dfa is dfa_comments:
            if state == 0:
                if c == '/':
                    state = 1
                else:
                    break
            elif state == 1:
                if c == '*':
                    state = 2
                else:
                    break
            elif state == 2:
                if c == '*':
                    state = 3
                else:
                    # 只要不是 '*', 留在狀態 2
                    state = 2
            elif state == 3:
                if c == '/':
                    state = 4
                elif c == '*':
                    state = 3
                else:
                    state = 2
            else:
                break

            if state in accept_states:
                last_accept = state
                last_accept_pos = i
            i += 1
            continue

        # 一般 DFA 狀態轉移
        transitions = dfa.get(state, {})

        if t in transitions:
            state = transitions[t]
        elif c in transitions:
            state = transitions[c]
        else:
            break

        if state in accept_states:
            last_accept = state
            last_accept_pos = i
        i += 1

    if last_accept == -1:
        return -1
    else:
        return last_accept_pos + 1


def lexer(text):
    i = 0
    length = len(text)
    tokens = []

    while i < length:
        c = text[i]
        t = char_type(c)

        # 跳過 layout  
        if t == 'layout':  
            i += 1  
            continue  

        try:
            # Comments DFA
            if text.startswith('/*', i):
                end_pos = run_dfa(
                    dfa_comments, comments_accept_states, text, i)
                if end_pos == -1:
                    tokens.append(('Binary Operators', '/'))
                    i += 1
                    continue
                else:
                    tokens.append(('Comments', text[i:end_pos]))
                    i = end_pos
                    continue

            # id DFA + keyword 判斷
            end_pos = run_dfa(dfa_id, id_accept_states, text, i)
            if end_pos != -1:
                word = text[i:end_pos]
                if word in keywords:
                    tokens.append(('Keyword', word))
                else:
                    tokens.append(('id', word))
                i = end_pos
                continue

            # float DFA
            end_pos = run_dfa(dfa_float, float_accept_states, text, i)
            if end_pos != -1:
                tokens.append(('float', text[i:end_pos]))
                i = end_pos
                continue

            # integer DFA
            end_pos = run_dfa(dfa_int, int_accept_states, text, i)
            if end_pos != -1:
                tokens.append(('integer', text[i:end_pos]))
                i = end_pos
                continue

            # 運算子優先匹配（長字串優先）
            matched_op = None
            for op in sorted(binary_Operators, key=lambda x: -len(x)):
                if text.startswith(op, i):
                    matched_op = op
                    break
            if matched_op:
                tokens.append(('Binary Operators', matched_op))
                i += len(matched_op)
                continue

            if c in brackets:
                tokens.append(('Brackets', c))
                i += 1
                continue

            if c in separators:
                tokens.append(('Separators', c))
                i += 1
                continue

            # 錯誤處理
            raise ValueError(f"Unknown token starting at position {i}: {c}")

        except ValueError as e:
            # 中止 lexer、印出目前 tokens
            print_results(tokens)

            raise e  # 讓主程式捕捉錯誤

    return tokens


def print_results(tokens):
    for ttype, val in tokens:
        print(f"{ttype:20}: {val}")


if __name__ == "__main__":
    try:
        with open("input.txt", "r", encoding="utf-8") as file:
            code = file.read()

        tokens = lexer(code)

        print_results(tokens)

    except ValueError as e:
        # 有錯誤的話就輸出錯誤訊息
        print(f"\nLexer Error: {e}")




```

---

## Demo

我們用一個 input.txt 的檔案作為輸入

![image](https://hackmd.io/_uploads/rJ9koUpXge.png)

### 正常情況

* 輸入
![image](https://hackmd.io/_uploads/HkiOj86Xle.png)

* 輸出
![image](https://hackmd.io/_uploads/SkTcoLp7gx.png)

### 特殊情況

#### 最長字串匹配

輸入會從前往後，從最常匹配的字串來判斷，像是輸入三個等於，會變成是前面兩個等號一組，後面單獨一個等號一組

* 輸入
![image](https://hackmd.io/_uploads/BJ1UnLTXxg.png)

* 輸出
![image](https://hackmd.io/_uploads/Sybv3Lp7gx.png)
這是因為他是用最常字串匹配的方式，他會先匹配最常符合的token類別
再來看第二個例子，他上會先匹配大於等於後再判斷另一個等於

#### 錯誤輸出

像是我在原本正確的測試，多加了一個小老鼠 @ 符號，他就會顯示 Unknown token starting at position，但原本前面正確的 token 都還是會正確的輸出

* 輸入
![image](https://hackmd.io/_uploads/B1hk6867lx.png)

* 輸出
![image](https://hackmd.io/_uploads/BkgWT8amle.png)

#### Comments

Comments 不會去管裡面寫些什麼，只要當作是 Comments 就會完整印出內容

* 輸入
![image](https://hackmd.io/_uploads/r1-pRLamgx.png)

* 輸出
![image](https://hackmd.io/_uploads/H1QC0UaQlg.png)

如果是沒有閉合的註解，那 \/ 和 \* 就會被判斷為 Binary Operator，而 comments 也就會被判斷成 id

* 輸入
![image](https://hackmd.io/_uploads/r1plkvTmgl.png)

* 輸出
![image](https://hackmd.io/_uploads/rkmM7tTXlx.png)


## 結論

我們用手繪的方式，將 Regular Expression 透過 Dotted Item 的方法轉換成 NFA，並畫出 NFA 圖形

我們使用的工具是 Inkscape 將手繪圖形繪製成電子檔案
![image](https://hackmd.io/_uploads/SksRxO6Qxe.png)

再用 NFA 圖形，畫出 DFA 的 transition table，接著將 DFA 的過程加入程式中，再不使用 lex 或 similar lexical analyzer的情況下，完成 lexical analysis 的實作去分析讀到哪些Token

## 參考資料

* 老師上課 PPT